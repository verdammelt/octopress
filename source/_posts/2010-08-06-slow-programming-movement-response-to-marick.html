---
layout: post
title: Slow Programming Movement (response to @marick & @RonJeffries)
published: true
date: 2010-08-06
categories: []
posterous_url: http://verdammelt.posterous.com/slow-programming-movement-response-to-marick
posterous_slug: slow-programming-movement-response-to-marick
---
<h2>Background</h2>

<p>On August 3 Brian Marick tweeted [1]</p>

<p>   Agile is a melding of a craft ethic and super-responsiveness to
   change. How would some explicit Slow Programming <a href="http://bit.ly/ieB4n">http://bit.ly/ieB4n</a>
   fit in?</p>

<p>Then, on August 4,  Ron Jeffries responded: [2]</p>

<p>   @marick I wonder if TDD might be &ldquo;Slow Programming&rdquo;</p>

<p>I also responded quickly &ndash; but wanted to take the time now fill in some
more details to my response[3].</p>

<p>This response is based upon my personal understanding of the &lsquo;Slow
Movement&rsquo;[4] which may or may not be entirely in line with the actual
goals/aspirations of the &lsquo;Slow Movement&rsquo;.  Also at the time of this
writing I find that there is already a Wikipedia entry for &lsquo;Slow
Programming&rsquo;[5] but I disagree with the description of that as linked
from the Wikipedia article[6].</p>

<h2>What Slow Programming means (to me)</h2>

<p>To me the &ldquo;Slow *&rdquo; movement is about being deliberate, mind-full and
sustainable.  Thus slow programming would involve programming in a way
that is done with thought, and is sustainable over a long term.  It
would not involve quick &ldquo;hacking&rdquo; of code to meet arbitrary deadlines in
a way that cannot be kept up for weeks/months/years.</p>

<p>The &lsquo;Agile&rsquo; process(es)/practices to me lead us to this &ldquo;Slow
Programming&rdquo;.  Specifically the practices of TDD &amp; Sustainable Pace.</p>

<p>We all know that going &lsquo;fast&rsquo; does not mean necessarily going &lsquo;well&rsquo;.
As Kent Beck says: &ldquo;If it doesn&rsquo;t need to work; I can get it done much
faster&rdquo;.</p>

<p>TDD leads me to program very mind-fully.  Always thinking of the next
thing the piece of code must do or not do.  Before TDD I would just
write the code I <em>thought</em> was needed for the requirement.  But with TDD
I write the requirement as a test and then write the code to make the
test pass.  That leads me to be constantly thinking about the
requirement; constantly questioning the requirement.  I am always asking
the &ldquo;Customer&rdquo; what they meant, do they mean &ldquo;this&rdquo; or &ldquo;that&rdquo;; and what
if &ldquo;something-else&rdquo; happens?  My code with TDD is not done more quickly
than before; but in the end I know exactly what it does; and it does not
more.  In the past my code might do things I had not intended (for
better or for worse).</p>

<p>Sustainable Pace keeps me from overextending myself for long periods of
time.  Of course when a important deadline looms I push; but through
long experience I know that pushing is a double edged sword: the stress
keeps me focused; but the speed reduces quality.</p>

<p>Programming needs to do be done very conscientiously and at a pace that
can be kept up in the long term.  One must always be 1) doing only that
which is needed, 2) questioning the customer what is needed to ensure #1
and 3) keeping up a good pace because burning out your resources are, in
my opinion, unprofessional, since it leads to worse code.</p>

<h2>In Reaction to the existing definition of Slow Programming</h2>

<p>When I began this blog post I was not aware of an existing &lsquo;definition&rsquo;
of Slow Programming[6].  That definition appears to be made in
opposition to Extreme Programming[7] and I think that is not the right
angle to take.  Given that we know that requirements will <em>always</em>
change (unless the &ldquo;Customer&rdquo; begins a &ldquo;Slow Business Requirement&rdquo;
Movement) the concept of having &ldquo;careful design process by a fairly
small number of people who know the business well&rdquo;[7] is not going to
work.  We must design only as much as possible to handle the given
requirements, meet them; then allow the &ldquo;Customer&rdquo; to play with them to
discover their next requirements. Perhaps this is the important part of
the &ldquo;Slow Programming&rdquo; concept: giving the &ldquo;Customer&rdquo; the time to
discover their own requirements &ndash; not rushing them to attempt to get all
their requirements before we start programming.</p>

<p>Footnotes:</p>

<p>[1]  <a href="http://twitter.com/marick/status/20272954242">http://twitter.com/marick/status/20272954242</a></p>

<p>[2]  <a href="http://twitter.com/RonJeffries/status/20273424668">http://twitter.com/RonJeffries/status/20273424668</a></p>

<p>[3]  <a href="http://twitter.com/verdammelt/status/20273317237">http://twitter.com/verdammelt/status/20273317237</a></p>

<p>[4]  <a href="http://en.wikipedia.org/wiki/Slow_movement">http://en.wikipedia.org/wiki/Slow_movement</a></p>

<p>[5]  <a href="http://en.wikipedia.org/wiki/Slow_Programming">http://en.wikipedia.org/wiki/Slow_Programming</a></p>

<p>[6]  <a href="http://johnmiedema.ca/2007/04/19/slow-programming-a-new-approach-to-software-development/">http://johnmiedema.ca/2007/04/19/slow-programming-a-new-approach-to-software-...</a></p>

<p>[7]  <a href="http://www.extremeprogramming.org/index.html">http://www.extremeprogramming.org/index.html</a></p>
